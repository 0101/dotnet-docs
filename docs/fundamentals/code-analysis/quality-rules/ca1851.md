---
title: "CA1851: Possible multiple enumerations of IEnumerable collection"
description: "Possible multiple enumerations of IEnumerable collection. Consider using an implementation that avoid multiple enumerations."
ms.date: 03/18/2022
ms.topic: reference
f1_keywords:
    - CA1851
helpviewer_keywords:
    - CA1851
author: Cosifne
ms.author: Cosifne
dev_langs:
- CSharp
- VB
---

# CA1851: Possible multiple enumerations of `IEnumerable` collection

| | Value |
|-|-|
| **Rule ID** |CA1851|
| **Category** |[Performance](performance-warnings.md)|
| **Fix is breaking or non-breaking** |Non-breaking|

## Cause

Multiple enumerations of `IEnumerable` collections are detected.

## Rule description

Collection with [IEnumerable](xref:System.Collections.IEnumerable) or [IEnumerable\<T\>](xref:System.Collections.Generic.IEnumerable`1) type generated by many LINQ methods like [Select](xref:System.Linq.Enumerable.Select*) or [yield](../../../csharp/language-reference/keywords/yield.md) in C# or [yield statement](../../../visual-basic/language-reference/statements/yield-statement.md) in Visual Basic has the ability to defer enumeration when it is generated. The enumeration will start as long as it is passed into enumeration LINQ methods like [ElementAt](xref:System.Linq.Enumerable.ElementAt*) or used in [for each statement](../../../csharp/language-reference/statements/iteration-statements.md#the-foreach-statement) in C# or [For Each..Next Statement](../../../visual-basic/language-reference//statements/for-each-next-statement.md) in Visual Basic. The enumeration result is not calculated once and cached like [Lazy](xref:System.Lazy`1).

If the enumeration operation itself is expansive, for example, query into the database, multiple enumerations would be harmful to the performance of the program.

If the enumeration operation causes some side-effects, multiple enumerations might cause bugs.

## How to fix violations

In general, if the underlying type of `IEnumerable` is some other types like `List` or `Array`. It is safe to convert the collection to its real type to fix the diagnostic.
For example:

**Violation**:

```csharp
public void MyMethod(IEnumerable<int> input)
{
    var count = inputArray.Count();
    foreach (var i in inputArray) { }
}
```

```vb
Public Sub MyMethod(input As IEnumerable(Of Integer))
    Dim count = input.Count()
    For Each i In input
    Next
End Sub
```

**Fix**:

```csharp
public void MyMethod(IEnumerable<int> input)
{
    // If the underlying type of 'input' is List<int>
    var inputArray = (List<int>)input;
    var count = inputArray.Count();
    foreach (var i in inputArray) { }
}
```

```vb
Public Sub MyMethod(input As IEnumerable(Of Integer))
    Dim inputArray = CType(input, Integer())
    Dim count = inputArray.Count()
    For Each i In inputArray
    Next
End Sub
```

If the underlying type of `IEnumerable` collection is an iterator-based implementation generated by [yield](../../../csharp/language-reference/keywords/yield.md) in C# or [yield statement](../../../visual-basic/language-reference/statements/yield-statement.md) in Visual Basic. It still can be fixed by converting and caching the collection to other types to fix the diagnostic. But it needs extra memory.
For example:

**Violation**:

```csharp
public void MyMethod()
{
    var someStrings = GetStrings().Select(i => string.Concat("Hello"));

    // It takes 2 * O(n) to complete 'Count()' and 'Last()' calls, where 'n' is the length of 'someStrings'.
    var count = someStrings.Count();
    var lastElement = someStrings.Last();
}
```

```vb
Public Sub MyMethod()
    Dim someStrings = GetStrings().Select(Function(i) String.Concat(i, "Hello"))

    ' It takes 2 * O(n) to complete 'Count()' and 'Last()' calls, where 'n' is the length of 'someStrings'.
    Dim count = someStrings.Count()
    Dim lastElement = someStrings.Last()
End Sub
```

**Fix**:

```csharp
public void MyMethod()
{
    var someStrings = GetStrings().Select(i => string.Concat("Hello"));
    // Cache it into an array.
    // Note: This operation would allocate O(n) memory,
    // and it takes O(n) time to finish, where 'n' is the length of 'someStrings'.
    var someStringsArray = someStrings.ToArray()

    // It takes 2 * O(1) to complete 'Count()' and 'Last()' calls.
    var count = someStringsArray.Count();
    var lastElement = someStringsArray.Last();
}
```

```vb
Public Sub MyMethod()
    Dim someStrings = GetStrings().Select(Function(i) String.Concat(i, "Hello"))
    ' Cache it into an array.
    ' Note: This operation would allocate O(n) memory,
    ' and it takes O(n) time to finish, where 'n' is the length of 'someStrings'.
    Dim someStringsArray = someStrings.ToArray()

    ' It takes 2 * O(1) to complete 'Count()' and 'Last()' calls.
    Dim count = someStrings.Count()
    Dim lastElement = someStrings.Last()
End Sub
```

## Configure customized enumeration methods and LINQ chain methods

By default, all the methods under `System.Linq` namespace are included in the analysis scope. Customized methods enumerating the `IEnumerable` parameters could be added into the scope by setting the [`enumeration_methods`](https://github.com/dotnet/roslyn-analyzers/blob/main/docs/Analyzer%20Configuration.md#enumeration-methods) in editorconfig.

Customized LINQ chain methods (methods take `IEnumerable` parameters and return a new `IEnumerable` instance) could also be added by setting the [`linq_chain_methods`](https://github.com/dotnet/roslyn-analyzers/blob/main/docs/Analyzer%20Configuration.md#linq-chain-methods) in editorconfig.

## Configure the default assumption of methods take `IEnumerable` parameters

By default, all the customized methods accepting `IEnumerable` parameters are considered not enumerating the parameters. It can changed by setting the [`assume_method_enumerates_parameters`](https://github.com/dotnet/roslyn-analyzers/blob/main/docs/Analyzer%20Configuration.md#assume-method-enumerates-parameters) in editorconfig.

## When to suppress warnings

It is safe to suppress the warnings if the underlying of the `IEnumerable` collection is some other type like `List` or `Array`, or if you are sure the methods accepting `IEnumerable` collection would not enumerated it.

## See also

[Deferred execution example (LINQ to XML)](https://docs.microsoft.com/en-us/dotnet/standard/linq/deferred-execution-example)
