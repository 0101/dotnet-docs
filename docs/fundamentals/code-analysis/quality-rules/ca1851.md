---
title: "CA1851: Possible multiple enumerations of `IEnumerable` collection"
description: "Possible multiple enumerations of `IEnumerable` collection. Consider using an implementation that avoid multiple enumerations."
ms.date: 03/18/2022
ms.topic: reference
f1_keywords:
    - CA1851
helpviewer_keywords:
    - CA1851
author: Cosifne
ms.author: Cosifne
dev_langs:
- CSharp
- VB
---

# CA1851: Possible multiple enumerations of `IEnumerable` collection

| | Value |
|-|-|
| **Rule ID** |CA1851|
| **Category** |[Performance](performance-warnings.md)|
| **Fix is breaking or non-breaking** |Non-breaking|

## Cause

Multiple enumerations of `IEnumerable` collections are detected.

## Rule description

Collection with [IEnumerable](https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerable?view=net-6.0) or [IEnumerable\<T\>](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1?view=net-6.0) type generated by many LINQ methods like [Select](https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.select?view=net-6.0) and [yield return](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield) statements has the ability to defer enumeration when it is generated. The enumeration will start as long as it is passed into enumeration LINQ methods like [ElementAt](https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.elementat?view=net-6.0) or used in [for each statement](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement). The enumeration result is not calculated once and cached like [Lazy](https://docs.microsoft.com/en-us/dotnet/api/system.lazy-1?view=net-6.0).

If the enumeration operation itself is expansive, for example, query into the database, multiple enumerations would be harmful to the program.

If the enumeration operation causes some side-effects, multiple enumerations might cause bugs.

## How to fix violations

In general, if the underlying type of `IEnumerable` is some other types like `List` or `Array`. It is safe to convert the collection to its real type to fix the diagnostic.
For example:

**Violation**:
```csharp
public void MyMethod(IEnumerable<int> input)
{
    var count = inputArray.Count();
    foreach (var i in inputArray) { }
}
```

**Fix**:
```csharp
public void MyMethod(IEnumerable<int> input)
{
    // If the underlying type of 'input' is List<int>
    var inputArray = (List<int>)input;
    var count = inputArray.Count();
    foreach (var i in inputArray) { }
}
```

If the underlying type of `IEnumerable` collection is an iterator-based implementation generated by [yield return](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield) statements. It still can be fixed by converting and caching the collection to other types to fix the diagnostic. But it needs extra memory.
For example:

**Violation**:
```csharp
public void MyMethod()
{
    // Example of diagnostic is reported
    var someStrings = GetStrings().Select(i => string.Concat("Hello"));

    // It takes 2 * O(n) to complete 'Count()' and 'Last()' calls, where 'n' is the length of 'someStrings'.
    var count = someStrings.Count();
    var lastElement = someStrings.Last();
}
```

**Fix**:
```csharp
public void MyMethod()
{
    var someStrings = GetStrings().Select(i => string.Concat("Hello"));
    // Cache it into an array.
    // Note: This operation would allocate O(n) memory,
    // and it takes O(n) time to finish, where 'n' is the length of 'someStrings'.
    var someStringsArray = someStrings.ToArray()

    // It takes 2 * O(1) to complete 'Count()' and 'Last()' calls.
    var count = someStringsArray.Count();
    var lastElement = someStringsArray.Last();
}
```

## Configure customized enumeration methods and LINQ chain methods.

By default, all the methods under `System.Linq` namespace are included in the analysis scope. Customized methods enumerating the `IEnumerable` parameters could be added into the scope by setting the [`enumeration_methods`](https://github.com/dotnet/roslyn-analyzers/blob/main/docs/Analyzer%20Configuration.md#enumeration-methods) in editorconfig.

Customized LINQ chain methods (methods take `IEnumerable` parameters and return a new `IEnumerable` instance) could also be added by setting the [`linq_chain_methods`](https://github.com/dotnet/roslyn-analyzers/blob/main/docs/Analyzer%20Configuration.md#linq-chain-methods) in editorconfig.

## Configure the default assumption of methods take `IEnumerable` parameters

By default, all the customized methods accepting `IEnumerable` parameters are considered not enumerating the parameters. It can changed by setting the [`assume_method_enumerates_parameters`](https://github.com/dotnet/roslyn-analyzers/blob/main/docs/Analyzer%20Configuration.md#assume-method-enumerates-parameters) in editorconfig.

## When to suppress warnings

It is safe to suppress the warnings if the underlying of the `IEnumerable` collection is some other type like `List` or `Array`, or if you are sure the methods accepting `IEnumerable` collection would not enumerated it.

## See also
